{-# LANGUAGE CPP #-}
module Main (main) where

import Control.Exception
import Control.Monad
import Data.Aeson (ToJSON(..), object, (.=))
import Data.Data (Data, Constr, cast, toConstr, showConstr, gmapQ)
import Data.List (isInfixOf, isPrefixOf)
import Data.String (fromString)
import Options.Applicative
import System.Process (readProcess)
import Text.Show.Pretty (Value(..), valToStr)
import qualified Data.Aeson           as Aeson
import qualified Data.ByteString.Lazy as B.Lazy
import qualified Data.Vector          as Vector

import Exception
import GHC
import HscTypes
import MonadUtils
import OccName
import Outputable (Outputable, showSDoc, ppr)
import Var

#if MIN_VERSION_base(4,8,0)
#else
import Data.Monoid (mconcat)
#endif

{-------------------------------------------------------------------------------
  Translate AST to Value
-------------------------------------------------------------------------------}

pretty :: Outputable a => a -> Ghc String
pretty x = do
#if MIN_VERSION_ghc(7,6,0)
  dynFlags <- getSessionDynFlags
  return $ showSDoc dynFlags (ppr x)
#else
  return $ showSDoc (ppr x)
#endif

-- | Construct a `Value` from any term implementing `data`
--
-- We have a number of special cases, solving two different kinds of problems:
--
-- * Some datatypes in GHC don't have an informative Data instance but are
--   marked as "abstract". We test for these types specifically so that we can
--   use a custom pretty-printer rather than just showing "{abstract}".
-- * Some subterms in ghc contain error values. We try to catch these and
--   show them as more readable strings (defaulting to showing the exception).
valueFromData :: Data a => a -> Ghc Value
valueFromData x
  | Just x' <- cast x :: Maybe ModuleName = pretty' x'
  | Just x' <- cast x :: Maybe Name       = pretty' x'
  | Just x' <- cast x :: Maybe OccName    = pretty' x'
  | Just x' <- cast x :: Maybe SrcSpan    = pretty' x'
  | Just x' <- cast x :: Maybe TyCon      = pretty' x'
  | Just x' <- cast x :: Maybe Var        = pretty' x'
  | otherwise = ghandle handleException $ do
      constrName <- liftIO $ evaluate $ showConstr constr
      Con constrName <$> sequence (gmapQ valueFromData x)
  where
    handleException :: SomeException -> Ghc Value
    handleException e =
      case isKnownPanic (show e) of
        Just panic -> return $ String $ "<<" ++ panic ++ ">>"
        Nothing    -> return $ String $ show (show e)

    isKnownPanic :: String -> Maybe String
    isKnownPanic e = msum $ map aux knownPanics
      where
        aux panic | panic `isInfixOf` e = Just panic
                  | otherwise           = Nothing

    knownPanics :: [String]
    knownPanics = [
        "PostTcExpr"
      , "PostTcKind"
      , "PostTcType"
      , "fixity"
      , "placeHolderNames"
      ]

    pretty' :: Outputable a => a -> Ghc Value
    pretty' = liftM (String . show) . pretty

    constr :: Constr
    constr = toConstr x

-- | Clean up a value generated by valueFromData
cleanupValue :: Value -> Value
cleanupValue (Con nm vals)
  | nm == "[]"  = case vals of
                    [] -> List []
                    _  -> error "cleanupValue: invalid tree"
  | nm == "(:)" = case vals of
                    [x, xs] -> case cleanupValue xs of
                                 List xs' -> List (cleanupValue x : xs')
                                 _        -> error "cleanupValue: invalid tree"
                    _       -> error "cleanupValue: invalid tree"
  | isTuple nm  = Tuple (map cleanupValue vals)
  | isBag   nm  = case vals of
                    [contents] -> Con "Bag.listToBag" [cleanupValue contents]
                    _          -> error "cleanupValue: invalid tree"
  | otherwise   = Con nm (map cleanupValue vals)
  where
    isTuple :: String -> Bool
    isTuple ('(' : nm') = all (== ',') (init nm') && last nm' == ')'
    isTuple _           = False

    isBag :: String -> Bool
    isBag = isPrefixOf "{abstract:Bag"

cleanupValue (String s) = String s
cleanupValue _          = error "cleanupValue: unexpected Value"

{-------------------------------------------------------------------------------
  Extracting ASTs from a set of targets
-------------------------------------------------------------------------------}

data Trees = Trees {
    treesModule     :: String
  , treeParsed      :: Value
  , treeRenamed     :: Value
  , treeTypechecked :: Value
  }

treesForModSummary :: ModSummary -> Ghc Trees
treesForModSummary modSummary = do
   parsed      <- parseModule modSummary
   typechecked <- typecheckModule parsed

   Trees <$> pretty (ms_mod_name modSummary)
         <*> mkTree (pm_parsed_source parsed)
         <*> (case tm_renamed_source typechecked of
                Just renamed -> mkTree renamed
                Nothing      -> return $ String $ show renamedTreeNotAvailable)
         <*> mkTree (tm_typechecked_source typechecked)
  where
    mkTree :: Data a => a -> Ghc Value
    mkTree = liftM cleanupValue . valueFromData

    renamedTreeNotAvailable :: String
    renamedTreeNotAvailable = "<<NOT AVAILABLE>>"

treesForTargets :: [FilePath] -> Ghc [Trees]
treesForTargets targets = do
    -- Don't compile anything
    dynFlags <- getSessionDynFlags
    let dynFlags' = dynFlags {
            hscTarget = HscNothing
          , ghcLink   = NoLink
          }
    void $ setSessionDynFlags dynFlags'

    -- Construct module graph
    setTargets (map mkTarget targets)
    void $ load LoadAllTargets

    -- Print each module
    hscEnv <- getSession
    mapM treesForModSummary $ hsc_mod_graph hscEnv
  where
    mkTarget :: FilePath -> Target
    mkTarget fp = Target {
        targetId           = TargetFile fp Nothing
      , targetAllowObjCode = False
      , targetContents     = Nothing
      }

{-------------------------------------------------------------------------------
  Dump the trees to stdout in text format
-------------------------------------------------------------------------------}

dumpText :: [Trees] -> IO ()
dumpText = mapM_ go
  where
    go :: Trees -> IO ()
    go Trees{..} = do
      section ("# " ++ treesModule) $ do
        section "##Â Parsed"      $ showTree treeParsed
        section "## Renamed"     $ showTree treeRenamed
        section "## Typechecked" $ showTree treeTypechecked

    section :: String -> IO () -> IO ()
    section title = bracket_ (putStrLn title) (putStrLn "")

    showTree :: Value -> IO ()
    showTree = putStrLn . valToStr

{-------------------------------------------------------------------------------
  Dump in JSON format
-------------------------------------------------------------------------------}

instance ToJSON Value where
  toJSON (Con nm [])   = Aeson.String (fromString nm)
  toJSON (Con nm vals) = object [ fromString nm .= list vals ]
  toJSON (Tuple  vals) = list vals
  toJSON (List   vals) = list vals
  toJSON (String s)    = Aeson.String (fromString s)
  toJSON _             = error "toJSON: Unexpected Value"

list :: ToJSON a => [a] -> Aeson.Value
list = Aeson.Array . Vector.fromList . map toJSON

instance ToJSON Trees where
  toJSON Trees{..} = object [
      "module"      .= treesModule
    , "parsed"      .= treeParsed
    , "renamed"     .= treeRenamed
    , "typechecked" .= treeTypechecked
    ]

dumpJson :: [Trees] -> IO ()
dumpJson = B.Lazy.putStr . Aeson.encode

{-------------------------------------------------------------------------------
  Main application
-------------------------------------------------------------------------------}

main :: IO ()
main = do
    libdir:_    <- lines <$> readProcess "ghc" ["--print-libdir"] ""
    Options{..} <- execParser opts
    trees       <- runGhc (Just libdir) (treesForTargets optionsTargets)
    if optionsDumpJson
      then dumpJson trees
      else dumpText trees
  where
    opts = info (helper <*> parseOptions) $ mconcat [
        fullDesc
      , header "ghc-dump-tree - Dump GHC's ASTs"
      ]

{-------------------------------------------------------------------------------
  Command line arguments
-------------------------------------------------------------------------------}

data Options = Options {
    optionsDumpJson :: Bool
  , optionsTargets  :: [FilePath]
  }

parseOptions :: Parser Options
parseOptions = Options
  <$> (switch $ mconcat [
          long "json"
        , help "Output JSON"
        ])
  <*> some (argument str (metavar "TARGETS..."))

{-------------------------------------------------------------------------------
  Orphans
-------------------------------------------------------------------------------}

#if MIN_VERSION_ghc(7,8,0)
#else
instance Applicative Ghc where
  pure  = return
  (<*>) = ap
#endif
