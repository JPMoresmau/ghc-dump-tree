{-# LANGUAGE CPP #-}
module Main (main) where

import Control.Exception
import Control.Monad
import Data.Data (Data, Constr, cast, toConstr, showConstr, gmapQ)
import Data.List (isInfixOf, isPrefixOf)
import Text.Show.Pretty (Value(..), valToStr)
import System.Environment (getArgs)
import System.Process (readProcess)

#if MIN_VERSION_base(4,8,0)
#else
import Control.Applicative
#endif

import Exception
import GHC
import HscTypes
import MonadUtils
import OccName
import Outputable (Outputable, showSDoc, ppr)
import Var

pretty :: Outputable a => a -> Ghc String
pretty x = do
#if MIN_VERSION_ghc(7,6,0)
  dynFlags <- getSessionDynFlags
  return $ showSDoc dynFlags (ppr x)
#else
  return $ showSDoc (ppr x)
#endif

-- | Construct a `Value` from any term implementing `data`
--
-- We have a number of special cases, solving two different kinds of problems:
--
-- * Some datatypes in GHC don't have an informative Data instance but are
--   marked as "abstract". We test for these types specifically so that we can
--   use a custom pretty-printer rather than just showing "{abstract}".
-- * Some subterms in ghc contain error values. We try to catch these and
--   show them as more readable strings (defaulting to showing the exception).
valueFromData :: Data a => a -> Ghc Value
valueFromData x
  | Just x' <- cast x :: Maybe ModuleName = pretty' x'
  | Just x' <- cast x :: Maybe Name       = pretty' x'
  | Just x' <- cast x :: Maybe OccName    = pretty' x'
  | Just x' <- cast x :: Maybe SrcSpan    = pretty' x'
  | Just x' <- cast x :: Maybe TyCon      = pretty' x'
  | Just x' <- cast x :: Maybe Var        = pretty' x'
  | otherwise = ghandle handleException $ do
      constrName <- liftIO $ evaluate $ showConstr constr
      Con constrName <$> sequence (gmapQ valueFromData x)
  where
    handleException :: SomeException -> Ghc Value
    handleException e =
      case isKnownPanic (show e) of
        Just panic -> return $ String $ "<<" ++ panic ++ ">>"
        Nothing    -> return $ String $ show (show e)

    isKnownPanic :: String -> Maybe String
    isKnownPanic e = msum $ map aux knownPanics
      where
        aux panic | panic `isInfixOf` e = Just panic
                  | otherwise           = Nothing

    knownPanics :: [String]
    knownPanics = [
        "PostTcExpr"
      , "PostTcKind"
      , "PostTcType"
      , "fixity"
      , "placeHolderNames"
      ]

    pretty' :: Outputable a => a -> Ghc Value
    pretty' = liftM (String . show) . pretty

    constr :: Constr
    constr = toConstr x

-- | Clean up a value generated by valueFromData
cleanupValue :: Value -> Value
cleanupValue (Con nm vals)
  | nm == "[]"  = case vals of
                    [] -> List []
                    _  -> error "cleanupValue: invalid tree"
  | nm == "(:)" = case vals of
                    [x, xs] -> case cleanupValue xs of
                                 List xs' -> List (cleanupValue x : xs')
                                 _        -> error "cleanupValue: invalid tree"
                    _       -> error "cleanupValue: invalid tree"
  | isTuple nm  = Tuple (map cleanupValue vals)
  | isBag   nm  = case vals of
                    [contents] -> Con "Bag.listToBag" [cleanupValue contents]
                    _          -> error "cleanupValue: invalid tree"
  | otherwise   = Con nm (map cleanupValue vals)
  where
    isTuple :: String -> Bool
    isTuple ('(' : nm') = all (== ',') (init nm') && last nm' == ')'
    isTuple _           = False

    isBag :: String -> Bool
    isBag = isPrefixOf "{abstract:Bag"

cleanupValue (String s) = String s
cleanupValue _          = error "cleanupValue: unexpected Value"

dumpModSummary :: ModSummary -> Ghc ()
dumpModSummary modSummary = do
   modName <- pretty (ms_mod_name modSummary)
   section ("# " ++ modName) $ do
     parsed      <- parseModule modSummary
     typechecked <- typecheckModule parsed

     section "##Â Parsed" $
       showTree $ pm_parsed_source parsed

     section "## Renamed" $
       case tm_renamed_source typechecked of
         Just renamed -> showTree renamed
         Nothing      -> liftIO $ putStrLn "<<NOT AVAILABLE>>"

     section "## Typechecked" $
       showTree $ tm_typechecked_source typechecked
  where
    section :: String -> Ghc () -> Ghc ()
    section title act = do
      liftIO $ putStrLn title
      act
      liftIO $ putStrLn ""

    showTree :: Data a => a -> Ghc ()
    showTree x = do
      value <- valueFromData x
      liftIO $ putStrLn $ valToStr (cleanupValue value)

dumpTargets :: [FilePath] -> Ghc ()
dumpTargets targets = do
    -- Don't compile anything
    dynFlags <- getSessionDynFlags
    let dynFlags' = dynFlags {
            hscTarget = HscNothing
          , ghcLink   = NoLink
          }
    void $ setSessionDynFlags dynFlags'

    -- Construct module graph
    setTargets (map mkTarget targets)
    void $ load LoadAllTargets

    -- Print each module
    hscEnv <- getSession
    mapM_ dumpModSummary $ hsc_mod_graph hscEnv
  where
    mkTarget :: FilePath -> Target
    mkTarget fp = Target {
        targetId           = TargetFile fp Nothing
      , targetAllowObjCode = False
      , targetContents     = Nothing
      }

main :: IO ()
main = do
    libdir:_ <- lines <$> readProcess "ghc" ["--print-libdir"] ""
    targets  <- getArgs
    runGhc (Just libdir) (dumpTargets targets)
